/**
 * DevExtreme (viz/core/plaque.js)
 * Version: 19.1.3
 * Build date: Tue May 14 2019
 *
 * Copyright (c) 2012 - 2019 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Plaque = void 0;
var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) {
                descriptor.writable = true
            }
            Object.defineProperty(target, descriptor.key, descriptor)
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) {
            defineProperties(Constructor.prototype, protoProps)
        }
        if (staticProps) {
            defineProperties(Constructor, staticProps)
        }
        return Constructor
    }
}();
var _extend = require("../../core/utils/extend");
var _type = require("../../core/utils/type");

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function")
    }
}
var round = Math.round;
var max = Math.max;
var min = Math.min;
var buildFlatArray = function() {
    var _ref;
    return (_ref = []).concat.apply(_ref, arguments)
};
var getCloudPoints = function(_ref2, x, y, anchorX, anchorY, _ref3) {
    var width = _ref2.width,
        height = _ref2.height;
    var arrowWidth = _ref3.arrowWidth;
    var halfArrowWidth = arrowWidth / 2;
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var xr = round(x + halfWidth);
    var xl = round(x - halfWidth);
    var yt = round(y - halfHeight);
    var yb = round(y + halfHeight);
    var leftTopCorner = [xl, yt];
    var rightTopCorner = [xr, yt];
    var rightBottomCorner = [xr, yb];
    var leftBottomCorner = [xl, yb];
    var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;
    var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;
    var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);
    var arrowBaseTop = max(arrowY - halfArrowWidth, yt);
    var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);
    var arrowBaseRight = min(arrowX + halfArrowWidth, xr);
    var points = void 0;
    if (xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {
        points = buildFlatArray(leftTopCorner, rightTopCorner, rightBottomCorner, leftBottomCorner)
    } else {
        if (anchorX < xl && anchorY < yt) {
            points = buildFlatArray([xl, arrowBaseBottom, anchorX, anchorY, arrowBaseRight, yt], rightTopCorner, rightBottomCorner, leftBottomCorner)
        } else {
            if (anchorX >= xl && anchorX <= xr && anchorY < yt) {
                points = buildFlatArray(leftTopCorner, [arrowBaseLeft, yt, anchorX, anchorY, arrowBaseRight, yt], rightTopCorner, rightBottomCorner, leftBottomCorner)
            } else {
                if (anchorX > xr && anchorY < yt) {
                    points = buildFlatArray(leftTopCorner, [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom], rightBottomCorner, leftBottomCorner)
                } else {
                    if (anchorX > xr && anchorY >= yt && anchorY <= yb) {
                        points = buildFlatArray(leftTopCorner, rightTopCorner, [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], rightBottomCorner, leftBottomCorner)
                    } else {
                        if (anchorX > xr && anchorY > yb) {
                            points = buildFlatArray(leftTopCorner, rightTopCorner, [xr, arrowBaseTop, anchorX, anchorY, arrowBaseLeft, yb], leftBottomCorner)
                        } else {
                            if (anchorX >= xl && anchorX <= xr && anchorY > yb) {
                                points = buildFlatArray(leftTopCorner, rightTopCorner, rightBottomCorner, [arrowBaseRight, yb, anchorX, anchorY, arrowBaseLeft, yb], leftBottomCorner)
                            } else {
                                if (anchorX < xl && anchorY > yb) {
                                    points = buildFlatArray(leftTopCorner, rightTopCorner, rightBottomCorner, [arrowBaseRight, yb, anchorX, anchorY, xl, arrowBaseTop])
                                } else {
                                    if (anchorX < xl && anchorY >= yt && anchorY <= yb) {
                                        points = buildFlatArray(leftTopCorner, rightTopCorner, rightBottomCorner, leftBottomCorner, [xl, arrowBaseBottom, anchorX, anchorY, xl, arrowBaseTop])
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return points
};
var Plaque = exports.Plaque = function() {
    function Plaque(options, widget, root, renderContent) {
        _classCallCheck(this, Plaque);
        this.widget = widget;
        this.options = options;
        this.root = root;
        this.renderContent = renderContent
    }
    _createClass(Plaque, [{
        key: "draw",
        value: function(_ref4) {
            var anchorX = _ref4.x,
                anchorY = _ref4.y,
                _ref4$canvas = _ref4.canvas,
                canvas = void 0 === _ref4$canvas ? {} : _ref4$canvas;
            var renderer = this.widget._renderer;
            var options = this.options;
            var x = options.x,
                y = options.y;
            var bounds = {
                xl: canvas.left,
                xr: canvas.width - canvas.right,
                width: canvas.width - canvas.right - canvas.left,
                yt: canvas.top,
                yb: canvas.height - canvas.bottom,
                height: canvas.height - canvas.bottom - canvas.top
            };
            if (!(0, _type.isDefined)(anchorX) && (!(0, _type.isDefined)(x) || !(0, _type.isDefined)(y))) {
                return
            }
            if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {
                return
            }
            var shadow = renderer.shadowFilter().attr((0, _extend.extend)({
                x: "-50%",
                y: "-50%",
                width: "200%",
                height: "200%"
            }, options.shadow));
            var cloudSettings = {
                opacity: options.opacity,
                filter: shadow.id,
                "stroke-width": 0,
                fill: options.color
            };
            var borderOptions = options.border || {};
            if (borderOptions.visible) {
                (0, _extend.extend)(cloudSettings, {
                    "stroke-width": borderOptions.width,
                    stroke: borderOptions.color,
                    "stroke-opacity": borderOptions.opacity,
                    dashStyle: borderOptions.dashStyle
                })
            }
            var group = renderer.g().attr({
                "class": "dxc-" + options.type + "-annotation"
            }).append(this.root);
            this._cloud = renderer.path([], "area").attr(cloudSettings).sharp().append(group);
            this._contentGroup = renderer.g().append(group);
            var contentWidth = options.width > 0 ? options.width : null;
            var contentHeight = options.height > 0 ? options.height : null;
            this.renderContent(this.widget, this._contentGroup, {
                width: contentWidth,
                height: contentHeight
            });
            var bBox = this._contentBBox = this._contentGroup.getBBox();
            var size = this._size = {
                width: max(contentWidth, bBox.width) + 2 * options.paddingLeftRight,
                height: max(contentHeight, bBox.height) + 2 * options.paddingTopBottom
            };
            if (!(0, _type.isDefined)(x)) {
                if (bounds.width < size.width) {
                    x = round(bounds.xl + bounds.width / 2)
                } else {
                    x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2)), Math.floor(bounds.xr - size.width / 2))
                }
            } else {
                if (!(0, _type.isDefined)(anchorX)) {
                    anchorX = x
                }
            }
            if (!(0, _type.isDefined)(y)) {
                var y_top = anchorY - options.arrowLength - size.height / 2;
                var y_bottom = anchorY + options.arrowLength + size.height / 2;
                if (bounds.height < size.height + options.arrowLength) {
                    y = round(bounds.yt + size.height / 2)
                } else {
                    if (y_top - size.height / 2 < bounds.yt) {
                        if (y_bottom + size.height / 2 < bounds.yb) {
                            y = y_bottom
                        } else {
                            y = round(bounds.yt + size.height / 2)
                        }
                    } else {
                        y = y_top
                    }
                }
            } else {
                if (!(0, _type.isDefined)(anchorY)) {
                    anchorY = y + size.height / 2
                }
            }
            this.anchorX = anchorX;
            this.anchorY = anchorY;
            this.move(x, y)
        }
    }, {
        key: "move",
        value: function(x, y) {
            this.x = x;
            this.y = y;
            this._cloud.attr({
                points: getCloudPoints(this._size, x, y, this.anchorX, this.anchorY, this.options)
            });
            this._contentGroup.move(x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2)
        }
    }, {
        key: "hitTest",
        value: function(x, y) {
            var _size = this._size,
                width = _size.width,
                height = _size.height;
            return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2
        }
    }]);
    return Plaque
}();
